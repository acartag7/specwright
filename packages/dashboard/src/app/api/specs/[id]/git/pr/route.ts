import { NextResponse } from 'next/server';
import { existsSync } from 'fs';
import { getSpec, getProject, getChunksBySpec, updateSpec } from '@/lib/db';
import {
  checkGitRepo,
  checkGitHubCLI,
  getCurrentBranch,
  createPullRequest,
  getCommitCount,
  getChangedFilesCount,
} from '@/lib/git';

interface RouteContext {
  params: Promise<{ id: string }>;
}

interface CreatePRRequest {
  title?: string;
  body?: string;
  baseBranch?: string;
}

/**
 * Generate PR body from spec content and chunks
 */
function generatePRBody(spec: { title: string; content: string }, chunks: { title: string; status: string }[]): string {
  const completedChunks = chunks.filter(c => c.status === 'completed');
  const chunksList = completedChunks.map(c => `- [x] ${c.title}`).join('\n');

  // Truncate spec content if too long
  let content = spec.content;
  if (content.length > 2000) {
    content = content.slice(0, 2000) + '\n\n*[Content truncated]*';
  }

  return `## ${spec.title}

${content}

---

### Chunks Completed
${chunksList || '- No chunks completed'}

---
*Generated by Spec-Driven Dev Platform*`;
}

// POST /api/specs/[id]/git/pr - Create pull request for spec
export async function POST(request: Request, context: RouteContext) {
  try {
    const { id: specId } = await context.params;
    const body = (await request.json()) as CreatePRRequest;

    // Get spec
    const spec = getSpec(specId);
    if (!spec) {
      return NextResponse.json({ error: 'Spec not found' }, { status: 404 });
    }

    // Check if PR already exists
    if (spec.prUrl) {
      return NextResponse.json({
        success: false,
        error: 'PR already exists for this spec',
        existingPr: {
          url: spec.prUrl,
          number: spec.prNumber,
        },
      }, { status: 400 });
    }

    // Get project for directory
    const project = getProject(spec.projectId);
    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 });
    }

    // Check directory exists
    if (!existsSync(project.directory)) {
      return NextResponse.json(
        { error: 'Project directory does not exist' },
        { status: 400 }
      );
    }

    // Check it's a git repo
    if (!checkGitRepo(project.directory)) {
      return NextResponse.json(
        { error: 'Not a git repository' },
        { status: 400 }
      );
    }

    // Check GitHub CLI
    const ghStatus = checkGitHubCLI();
    if (!ghStatus.installed) {
      return NextResponse.json(
        { error: 'GitHub CLI (gh) is not installed. Install it from https://cli.github.com/' },
        { status: 400 }
      );
    }
    if (!ghStatus.authenticated) {
      return NextResponse.json(
        { error: 'Not authenticated with GitHub. Run: gh auth login' },
        { status: 401 }
      );
    }

    // Check we're on a branch (not detached HEAD)
    const currentBranch = getCurrentBranch(project.directory);
    if (!currentBranch) {
      return NextResponse.json(
        { error: 'Not on a branch (detached HEAD state)' },
        { status: 400 }
      );
    }

    const baseBranch = body.baseBranch || 'main';

    // Check not on base branch
    if (currentBranch === baseBranch) {
      return NextResponse.json(
        { error: `Already on ${baseBranch} branch. Create a feature branch first using the "Create Branch" action.` },
        { status: 400 }
      );
    }

    // Generate PR title if not provided
    const prTitle = body.title || spec.title;

    // Generate PR body if not provided
    let prBody = body.body;
    if (!prBody) {
      const chunks = getChunksBySpec(specId);
      prBody = generatePRBody(spec, chunks);
    }

    // Create the PR
    const result = await createPullRequest(project.directory, prTitle, prBody, baseBranch);

    if (!result.success) {
      return NextResponse.json(
        { error: result.error || 'Failed to create PR' },
        { status: 400 }
      );
    }

    // Update spec with PR info
    updateSpec(specId, {
      prNumber: result.prNumber,
      prUrl: result.prUrl,
      status: 'completed', // Mark spec as completed when PR is created
    });

    return NextResponse.json({
      success: true,
      prNumber: result.prNumber,
      prUrl: result.prUrl,
      title: prTitle,
      branch: currentBranch,
      baseBranch,
    });
  } catch (error) {
    console.error('Error creating PR:', error);
    return NextResponse.json(
      { error: `Failed to create PR: ${error instanceof Error ? error.message : 'Unknown error'}` },
      { status: 500 }
    );
  }
}

// GET /api/specs/[id]/git/pr - Get PR status for spec
export async function GET(request: Request, context: RouteContext) {
  try {
    const { id: specId } = await context.params;

    const spec = getSpec(specId);
    if (!spec) {
      return NextResponse.json({ error: 'Spec not found' }, { status: 404 });
    }

    const project = getProject(spec.projectId);
    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 });
    }

    if (!existsSync(project.directory)) {
      return NextResponse.json(
        { error: 'Project directory does not exist' },
        { status: 400 }
      );
    }

    if (!checkGitRepo(project.directory)) {
      return NextResponse.json({
        isGitRepo: false,
        hasPR: false,
      });
    }

    const baseBranch = 'main';
    const currentBranch = getCurrentBranch(project.directory);
    const commitCount = getCommitCount(project.directory, baseBranch);
    const filesChanged = getChangedFilesCount(project.directory, baseBranch);

    return NextResponse.json({
      isGitRepo: true,
      hasPR: !!spec.prUrl,
      prUrl: spec.prUrl || null,
      prNumber: spec.prNumber || null,
      branchName: spec.branchName || null,
      currentBranch,
      commitCount,
      filesChanged,
      canCreatePR: currentBranch !== baseBranch && !spec.prUrl,
    });
  } catch (error) {
    console.error('Error getting PR status:', error);
    return NextResponse.json(
      { error: `Failed to get PR status: ${error instanceof Error ? error.message : 'Unknown error'}` },
      { status: 500 }
    );
  }
}
